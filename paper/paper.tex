
\title{ Data Encryption Standard Implementation 4003-482-01 RIT }

\author{
Brian Gianforcaro \and Sam Milton \\
}

\date{\today}

\documentclass[10pt]{article}

\oddsidemargin0cm
\topmargin-2cm     %I recommend adding these three lines to increase the
\textwidth16.5cm   %amount of usable space on the page (and save trees)
\textheight23.5cm

\usepackage{graphicx}
\usepackage{multicol}
% \usepackage{acronym}
\usepackage[bookmarks=false,colorlinks=false,linkcolor={black},pdfstartview={XYZ null null 1.22}]{hyperref}
\usepackage{url}

% \usepackage{mdwlist}
% \usepackage{amssymb,amsmath}
% \usepackage{cite}
% \usepackage[T1]{fontenc}

% \acrodef{DES}[DES]{Data Encryption Standard}
% \acrodef{TDD}[TDD]{Test Driven Development}
% \acrodef{OOP}[OOP]{Object Oriented Programming}

\begin{document}

\maketitle

\begin{abstract}
  {DES} is the 56-bit block cipher that was once used to encrypt all US Government non-classified documents.
\end{abstract}

\newpage

\part{The Cryptographic Primitive}

\section{Examples}
Each was encrypted using the key $24681012$.
\subsection{Example 1}
\textit{Hello}
\\\indent Original:
\begin{verbatim}
   48 65 6C 6C 6F 0A
\end{verbatim}
\indent Encrypted:
\begin{verbatim}
   94 93 81 0E 62 47 30 86
\end{verbatim}

\subsection{Example 2}
\textit{World}
\\\indent Original:
\begin{verbatim}
   57 6F 72 6C 64 0A
\end{verbatim}
\indent Encrypted:
\begin{verbatim}
   24 0B A5 B2 CB C1 F2 8B
\end{verbatim}

\subsection{Example 3}
\textit{Hello World}
\\\indent Original:
\begin{verbatim}
   48 65 6C 6C 6F 20 57 6F
   72 6C 64 0A
\end{verbatim}
\indent Encripted:
\begin{verbatim}
   E6 74 22 8A AC 1E 85 ED
   B7 3C 26 3C 4B B4 F1 77
\end{verbatim}

\subsection{Example 4}
\textit{The quick brown fox jumps over the lazy dog}
\\\indent Original:
\begin{verbatim}
   54 68 65 20 71 75 69 63
   6B 20 62 72 6F 77 6E 20
   66 6F 78 20 6A 75 6D 70
   73 20 6F 76 65 72 20 74
   68 65 20 6C 61 7A 79 20
   64 6F 67 0A
\end{verbatim}
\indent Encrypted:
\begin{verbatim}
   09 D1 3F 78 9D C7 66 B7
   46 52 A9 9F 57 92 38 65
   8B 40 39 1C 21 9E 77 D7
   9B 84 62 AF E9 22 25 1D
   96 61 A7 22 09 97 2C D2
   16 F5 D8 38 E4 FF C6 86
\end{verbatim}

\section{Software Design}
Our implementation of DES was done entirely in C++. This was chosen since both members were knowledgeable and comfortable using C++.

Our DES implementation is contained in one class. The implementation is spread across 4 functions; algorithm(), keyschedule(), mixer(), f(). Algorithm() is the starting point. It calls keyschedule() to set up the keys, uses mixer() to perform the initial permutation, then runs the 16 rounds, and ends by using mixer() again to do the inverse initial permutation.  Each round first picks the round's key, calls the f() function, and then swaps the two halves of the key.

The keyschedule() function first uses mixer() to do permutation choice 1.  It then generates 16 sub keys.  Each sub key is generated by shifting the bits 1 or 2 times then using mixer() to do permutation choice 2.

The mixer() function isn't specifically part of the DES spec. DES has many instances where bits must be reordered, we wrote one function, mixer(), which can be passed data and an array defining how to rearrange things and it will rearrange them.

The last function, f(), also known as the Feistel function, is the heart of the encryption.  It first uses mixer() to do the expansion permutation, then xor's the result with the sub key. This output is split into 8-bit block and each block is sent through an S-Box. The output from the S-Boxes is then concatenated run through mixer() using the primitive permutation.
\\ \\ \\
We chose to implement DES completely in $C++$ for this project.
Both of the members our group were knowledgeable and comfortable
with $C++$ and in the $C$ world in general. We felt we would have a more
generally usable and useful implementation if we went with $C++$ over
another language (Java, Python, ... ). We attempted to take advantage of ac{OOP} but
were careful not to over do it and dive into a downword spiral of subclasses and
analysis of class cohesion. Our $DES$ implementation is simply a class, with actions of encrypting and
decrypting. All state information is organized within the class. We then
implemented a $BlockMode$ class which implements a block stream cipher, which is
just a wrapper around $DES$. The user is then provided with
two small utility functions $encrypt$ \and $decrypt$.

The general ideology of this first iteration is that we want the code to be clean and correct.
We are not putting too much thought into optimization and efficiency. We are very familiar
with the old Donal Knuth quote:


   "We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil"


During the duration of the project we attempted to work in a {TDD} model.
All major functions and actions have associated unit-tests which we derived from various peices of
literature on DES. These unit test's were then hooked up to run using the Google Test Framework \cite{gtest}.

\section{Original Runtime Measurements}
\paragraph{}Each test consisted of 1,000,000 encryptions of the message 123456789ABCDEF and key 133457799BBCDFF1. They were performed on a 1.8 Ghz Core2Duo computer running Ubuntu 10.04.
\\Test 1:
\\ \indent 10.899 seconds
\\Test 2:
\\ \indent 10.867 seconds
\\Test 3:
\\ \indent 10.870 seconds
\\\\Average:
\\ \indent 10.879 seconds
\begin{verbatim}
  % of   # of      # of
  time  Seconds    Calls      Name
 40.93   18.00   51,000,000   DES::mixer()
 22.88   10.06   16,000,000   DES::f()
 20.17    8.87    1,000,000   DES::keyschedule()
  8.20    3.60    1,000,000   DES::algorithm()
  5.59    2.46  512,000,000   DES::get()
  0.61    0.27   32,000,000   std::swap<T>()
  0.53    0.23    1,000,000   std::swap_ranges<T,G>()
  0.41    0.18   32,000,000   std::__iter_swap<T>::iter_swap<G,E>()
  0.28    0.12   32,000,000   std::iter_swap<T,G>()
  0.20    0.09                DES::on()
  0.11    0.05    1,000,000   DES::DES()
  0.02    0.01    1,000,000   DES::encrypt()
  0.02    0.01    1,000,000   DES::~DES()
  0.02    0.01                DES::main
\end{verbatim}
\section{Original Runtime Analysis and Design Changes}
\indent With a total run time of 10.884 seconds, this means each encryption took only .01 milliseconds.  To find improvements, we look at our profiling.  The most time was spent in our mixer function.  To reduce this we decided to 'unravel' the loop.  To do this we would have had to make a unique method for each of the different mixing procedures.  However instead we decided to get rid of it all together by putting the unraveled contents wherever mixer() was called from.
\\ \indent The next worst function was the f (feistel) function.  One of the first things we noticed could be done for improvment was to remove the first for-loop. First it mixes the input, then runs through it again doing xor with the key. We combined the two steps into the already unraveled and inlined mix procedure. Also, instead of using our get method to retrieve bit values, we copied the code into the function and hard coded the values that were needed for each use.
\\ \indent After this we analyzed the keyschedule algorithm, as this was \#3 in terms of time spent executing.  We had already internalized the mixer function.  The innermost for loop was unraveld to remove time spent computing the the counter and comparisons.  Also, we turned the for-loop outside of it into a do-while loop.  This made modest savings since in cases where it only loops once, since there are no extra jumps.  At the end of the function was one of the unraveled mix algorithms.  We combined this with the for loop afterwards so that we weren't running through each element twice.

\section{Revised Runtime Measurements}
\paragraph{}Each test consisted of 1,000,000 encryptions of the message 123456789ABCDEF and key 133457799BBCDFF1. They were performed on a 1.8 Ghz Core2Duo computer running Ubuntu 10.04.
\\Test 1:
\\ \indent 5.960 seconds
\\Test 2:
\\ \indent 6.012 seconds
\\Test 3:
\\ \indent 5.903 seconds
\\\\Average:
\\ \indent 5.958 seconds
\begin{verbatim}
  % of   # of      # of
  Time  Seconds    Calls      Name
 42.90    6.10   16,000,000   DES::f()
 24.40    3.47    1,000,000   DES::keyschedule()
 24.19    3.44    1,000,000   DES::algorithm()
  2.04    0.29    1,000,000   DES::inverseInitPermutation()
  2.04    0.29    1,000,000   std::swap_ranges<T,T>()
  1.30    0.18   32,000,000   std::iter_swap<T,T>()
  1.02    0.14   32,000,000   std::__iter_swap<G>::iter_swap<T,T>()
  0.91    0.13    1,000,000   DES::initPermutation()
  0.70    0.10   32,000,000   std::swap<unsigned char>()
  0.21    0.03    1,000,000   DES::~DES()
  0.14    0.02    1,000,000   DES::DES()
  0.07    0.01    1,000,000   DES::encrypt()
  0.07    0.01                main
\end{verbatim}

\section{Revised Runtime Analysis}
  One of the major changes was the f (feistel) function. It went from 23\% to 43\% of the total runtime.  This change is largely because we removed the mixer function. Mixer accounted for 41\% of the runtime, 63\% of mixer's calls were from feistel.  From this we can deduce that 26\% out of the 41\% was directly due to f, and we could say that f really caused 23\% + 26\% = 49\% of the runtime.  From this we can see that the f function's overall contribution to execution time went down without removing any of its duties. 
\section{Developers manual}

\indent  The build environment of our software was designed to be as simple to use as possible.
  The only dependency to compiler our encrypt and decrypt programs is any modern C++ compiler, we recommend the GNU Compiler Collection's G++.
  To build just the main $encrypt$ and $decrypt$ utilties the developer must simply move to the src directory of the distribution and then issue $make$ command.

{\footnotesize
\begin{verbatim}

$ make
g++ -o encrypt_orig  -g3 -pg -Wall -Wextra -ansi -pedantic des_original.cpp encrypt.cpp blockmode.cpp
g++ -o decrypt_orig  -g3 -pg -Wall -Wextra -ansi -pedantic des_original.cpp decrypt.cpp blockmode.cpp
g++ -o encrypt_opt  -g3 -pg -Wall -Wextra -ansi -pedantic -DDESOPTIMIZED des.cpp encrypt.cpp blockmode.cpp
g++ -o decrypt_opt  -g3 -pg -Wall -Wextra -ansi -pedantic -DDESOPTIMIZED des.cpp decrypt.cpp blockmode.cpp

\end{verbatim}
}
\noindent  This will build 4 binaries in total, an optimized $encrypt$ and $decrypt$ as well as our original implementation $encrypt$ and $decrypt$.
  The two set's of binaries are denoted by the "\_opt" for optimized and "\_orig" for original appended to each.
  Our distribution also comes with unit-tests and a sample program to perform performance tests with.
  In order to build the unit tests you will need the Google Testing Framework available from http://code.google.com/p/googletest/ or it is
  probabably available in your package manager if you are using a unix system. For example if you are on any Ubuntu/Debian machine you should just need to run the following command:
{\footnotesize
\begin{verbatim}
$ sudo apt-get install libgtest-dev
\end{verbatim}
}
\noindent You can then build the testers and run them all automatically:
{\footnotesize
\begin{verbatim}
$ make test
g++ -o tester_orig  -lgtest -g3 -pg -Wall -Wextra -ansi -pedantic -DUNITTEST blockmode.cpp des_original.cpp test.cpp
g++ -o perftest_orig  -g3 -pg -Wall -Wextra -ansi -pedantic  -DUNITTEST des_original.cpp performance.cpp
g++ -o tester_opt  -lgtest -g3 -pg -Wall -Wextra -ansi -pedantic -DUNITTEST -DDESOPTIMIZED blockmode.cpp des.cpp test.cpp
g++ -o perftest_opt  -g3 -pg -Wall -Wextra -ansi -pedantic  -DUNITTEST -DDESOPTIMIZED des.cpp performance.cpp

.... test output ...
\end{verbatim}
}

\section{Users Manual}

In order to encrypt a file using out implementation the user must run the executable \textbf{encrypt\_opt}.
\begin{verbatim}

  Usage: ./encrypt_opt <infile> <outfile> <key>

    <infile>  - The file you wish to encrypt
    <outfile> - The resulting encrypted file
    <key>     - 8 character string for your key

\end{verbatim}

The user has a similar choice for decrypting, both an optimized and original implementation exist.
\begin{verbatim}

  Usage: ./decrypt_opt <infile> <outfile> <key>

    <infile>  - The file you wish to decrypt
    <outfile> - The resulting decrypted file
    <key>     - 8 character string for your key
    <key>     - 8 character string for your key

\end{verbatim}

\section{What we learned}
One of the very first things we learned is that in order to implement the specification, we would have to put much thought and careful interpretation into it. A big contributing factor to this is that the documentation for cryptographic specs is more complicated that what we're used to.

We quickly discovered after our very first implementation, that even after trying to carefully follow the spec, it is very easy to make a mistake which messes everything up.  We spent a fair amount of time debugging our algorithm to get it right.

It was also surprising to see how much performance was regained simply by unrolling loops and removing function calls. We didn't expect to see as much of an improvement from that as we got.
\section{Future Work}

  In the realm of future work we believe the first thing we would like to change is the cipher block mode we chose.
  We initially chose Electronic Codebook (ECB) mode for our implementation because of the simplicity of the algorithm.
  However for this implementation to be actually useful for legitimate security uses the program would have to be extended
  to support alternative block modes which are not as insecure as ECB.

  Another possible improvement to our implementation of DES would be to reorganize how the data input block and key block
  are stored and used in the algorithm. Since DES has many permutations which reorganize the location of specific bits we 
  stored the data and key blocks as array's of individual bits. It is most likely possible to keep the key and data blocks
  organized as 8 bytes. I believe it would be possible to reduce the number of operations required total if we could bundle the 
  bits together and then perform operations on the total bundles, much like the implementation of Skein presented in class. 
  With this change I believe we could have a far superior implementation of DES than our current version. I am afraid that it
  would be just out of our knowledge range to be able to actually implement it. 

  There also exist a few small for loops in the code which might benefit slightly from being unrolled.
  We chose not to unroll them because in our profiling they didn't seem to be a problem. Also to unroll
  these left over loops would affect the readability of the code tremendously, many things would need to be 
  restructured. However unrolling all the loops might achieve a slight speed up to the overall speed of implementation.
  The difference mostly depends on the quality of the optimizations being performed by the compiler.

\section{Team Member Work}

  At the start of the project we divided up th major parts of the cipher implementation for each person to do. \\


  \textbf{Brian:}
  \begin{itemize}
    \item Unit test setup
    \item Build system
    \item Gathering of all constants and permutation blocks.
    \item Key schedule
    \item Main DES algorithm
  \end{itemize}

  \textbf{Sam:}
  \begin{itemize}
    \item Bit operators and converters
    \item Feistel function
    \item Implementation API design
    \item Mix function to handle mixing
    \item Block mode implementation
  \end{itemize}

  Once these tasks were complete we worked together to integrate all parts together and debug our final product. Most of this
  time was spent pair programming. The presentation and this paper were split up similarly but much of the work was done together, 
  working cooperatively.


\begin{thebibliography}{99}

  \bibitem{ gtest }{ \href{ http://code.google.com/p/googletest/ }{ Google Unit Testing Framework } }
  \bibitem{ spec  }{ \href{ http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf }{ Data Encryption Standard Specification } }
  \bibitem{ wiki  }{ \href{ http://en.wikipedia.org/wiki/Data_Encryption_Standard }{ Wikipedia: Data Encryption Standard } }
  \bibitem{ block }{ \href{ http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation }{ Wikipedia: Block Cipher Modes } }
  \bibitem{ desge }{ \href{ http://www.comms.scitech.sussex.ac.uk/fft/crypto/des_algorithm_details.txt}{ How to implement the Data Encryption Standard (DES) } }
  \bibitem{ desg2 }{ \href{ http://orlingrabbe.com/des.htm }{ DES Illustrated } }
  \bibitem{ gprof }{ \href{ http://linux.die.net/man/1/gprof }{ GProf Manual Page } }
  \bibitem{ g++ }{ \href{ http://linux.die.net/man/1/g++ }{ GCC Manual Page } }


\end{thebibliography}

\end{document}
