
\title{ Data Encryption Standard Implementation 4003-482-01 RIT }

\author{
Brian Gianforcaro \and Sam Milton \\
}

\date{\today}

\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{multicol}
% \usepackage{acronym}
\usepackage[bookmarks=false,colorlinks=false,linkcolor={black},pdfstartview={XYZ null null 1.22}]{hyperref}
\usepackage{url}

% \usepackage{mdwlist}
% \usepackage{amssymb,amsmath}
% \usepackage{cite}
% \usepackage[T1]{fontenc}


% \acrodef{DES}[DES]{Data Encryption Standard}
% \acrodef{TDD}[TDD]{Test Driven Development}
% \acrodef{OOP}[OOP]{Object Oriented Programming}

\begin{document}

\maketitle

\begin{abstract}
  {DES} is the 56-bit block cipher that was once used to encrypt all US Government non-classified documents.
\end{abstract}

\newpage
\section{The Cryptographic Primitive}

\section{Examples}
Each was encrypted using the key $24681012$.
\subsection{Example 1}
\textit{Hello}
\\\indent Original:
\begin{verbatim}
   48 65 6C 6C 6F 0A
\end{verbatim}
\indent Encrypted:
\begin{verbatim}
   94 93 81 0E 62 47 30 86
\end{verbatim}

\subsection{Example 2}
\textit{World}
\\\indent Original:
\begin{verbatim}
   57 6F 72 6C 64 0A
\end{verbatim}
\indent Encrypted:
\begin{verbatim}
   24 0B A5 B2 CB C1 F2 8B 
\end{verbatim}

\subsection{Example 3}
\textit{Hello World}
\\\indent Original:
\begin{verbatim}
   48 65 6C 6C 6F 20 57 6F
   72 6C 64 0A
\end{verbatim}
\indent Encripted:
\begin{verbatim}
   E6 74 22 8A AC 1E 85 ED 
   B7 3C 26 3C 4B B4 F1 77
\end{verbatim}

\subsection{Example 4}
\textit{The quick brown fox jumps over the lazy dog}
\\\indent Original:
\begin{verbatim}
   54 68 65 20 71 75 69 63 
   6B 20 62 72 6F 77 6E 20 
   66 6F 78 20 6A 75 6D 70 
   73 20 6F 76 65 72 20 74 
   68 65 20 6C 61 7A 79 20 
   64 6F 67 0A
\end{verbatim}
\indent Encrypted:
\begin{verbatim}
   09 D1 3F 78 9D C7 66 B7 
   46 52 A9 9F 57 92 38 65 
   8B 40 39 1C 21 9E 77 D7 
   9B 84 62 AF E9 22 25 1D 
   96 61 A7 22 09 97 2C D2 
   16 F5 D8 38 E4 FF C6 86
\end{verbatim}
	
\section{Software Design}
We chose to implement DES completely in $C++$ for this project.
Both of the members our group were knowledgeable and comfortable
with $C++$ and in the $C$ world in general. We felt we would have a more
generally usable and useful implementation if we went with $C++$ over
another language (Java, Python, ... ). We attempted to take advantage of ac{OOP} but
were careful not to over do it and dive into a downword spiral of subclasses and
analysis of class cohesion. Our $DES$ implementation is simply a class, with actions of encrypting and
decrypting. All state information is organized within the class. We then
implemented a $BlockMode$ class which implements a block stream cipher, which is
just a wrapper around $DES$. The user is then provided with
two small utility functions $encrypt$ \and $decrypt$.

The general ideology of this first iteration is that we want the code to be clean and correct.
We are not putting too much thought into optimization and efficiency. We are very familiar
with the old Donal Knuth quote:


   "We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil"


During the duration of the project we attempted to work in a {TDD} model.
All major functions and actions have associated unit-tests which we derived from various peices of
literature on DES. These unit test's were then hooked up to run using the Google Test Framework\cite{gtest}.

\section{Original Runtime Measurements}
\paragraph{}Each test consisted of 1,000,000 encryptions of the message 123456789ABCDEF and key 133457799BBCDFF1. They were performed on a 1.8 Ghz Core2Duo computer running Ubuntu 10.04.
\\Test 1:
\\ \indent 10.899 seconds
\\Test 2:
\\ \indent 10.867 seconds
\\Test 3:
\\ \indent 10.870 seconds
\\\\Average:
\\ \indent 10.879 seconds
\section{Original Runtime Analysis}
\section{Revised Software design}
\section{Revised Runtime Measurements}
\paragraph{}Each test consisted of 1,000,000 encryptions of the message 123456789ABCDEF and key 133457799BBCDFF1. They were performed on a 1.8 Ghz Core2Duo computer running Ubuntu 10.04.
\\Test 1:
\\ \indent 5.960 seconds
\\Test 2:
\\ \indent 6.012 seconds
\\Test 3:
\\ \indent 5.903 seconds
\\\\Average:
\\ \indent 5.958 seconds
\section{Revised Runtime Analysis}
\section{Developers manual}
\section{Users Manual}

\begin{verbatim}

  Usage: ./encrypt_opt <infile> <outfile> <key>

    <infile>  - The file you wish to encrypt
    <outfile> - The resulting encrypted file
    <key>     - 8 character string for your key

  OR

  Usage: ./encrypt_orig <infile> <outfile> <key>

    <infile>  - The file you wish to encrypt
    <outfile> - The resulting encrypted file
    <key>     - 8 character string for your key


\end{verbatim}

\begin{verbatim}

  Usage: ./decrypt_opt <infile> <outfile> <key>

    <infile>  - The file you wish to decrypt
    <outfile> - The resulting decrypted file
    <key>     - 8 character string for your key

  OR

  Usage: ./decrypt_orig <infile> <outfile> <key>

    <infile>  - The file you wish to decrypt
    <outfile> - The resulting decrypted file
    <key>     - 8 character string for your key

\end{verbatim}

\section{What we learned}

\section{Future Work}

  In the realm of future work we believe the first thing we would like to change is the cipher block mode we chose.
  We initially chose Electronic Codebook (ECB) mode for our implementation because of the simplicity of the algorithm.
  However for this implementation to be actually useful for legitimate security uses the program would have to be extended
  to support alternative block modes which are not as insecure as ECB.

  Another possible improvement to our implementation of DES would be to reorganize how the data input block and key block
  are stored and used in the algorithm. Since DES has many permutations which reorganize the location of specific bits we 
  stored the data and key blocks as array's of individual bits. It is most likely possible to keep the key and data blocks
  organized as 8 bytes. I believe it would be possible to reduce the number of operations required total if we could bundle the 
  bits together and then perform operations on the total bundles, much like the implementation of Skein presented in class. 
  With this change I believe we could have a far superior implementation of DES than our current version. I am afraid that it
  would be just out of our knowledge range to be able to actually implement it. 

  There also exist a few small for loops in the code which might benifit slightly from being unrolled.
  We chose not to unroll them because in our profiling they didn't seem to be a problem. Also to unroll
  these left over loops would affect the readability of the code tremendously, many things would need to be 
  restructured. However unrolling all the loops might achive a slight speed up to the overall speed of implementation.
  The difference mostly depends on the quality of the optimizations being performed by the compiler.

\section{Team Member Work}

\begin{thebibliography}{99}

  \bibitem{ gtest }{ \href{ http://code.google.com/p/googletest/ }{ Google Unit Testing Framework } }
  \bibitem{ spec  }{ \href{ http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf }{ Data Encryption Standard Specification } }
  \bibitem{ wiki  }{ \href{ http://en.wikipedia.org/wiki/Data_Encryption_Standard }{ Wikipedia: Data Encryption Standard } }
  \bibitem{ block }{ \href{ http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation }{ Wikipedia: Block Cipher Modes } }

  \bibitem{ desge }{ \href{ http://www.comms.scitech.sussex.ac.uk/fft/crypto/des_algorithm_details.txt}{ How to implement the Data Encryption Standard (DES) } }
  \bibitem{ desg2 }{ \href{ http://orlingrabbe.com/des.htm }{ DES Illustrated } }
  \bibitem{ gprof }{ \href{ http://linux.die.net/man/1/gprof }{ GProf Manual Page } }
  \bibitem{ g++ }{ \href{ http://linux.die.net/man/1/g++ }{ GCC Manual Page } }


\end{thebibliography}

\end{document}
